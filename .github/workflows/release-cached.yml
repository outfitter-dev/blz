name: Release (Cached)

# This workflow reuses build artifacts from the CI pipeline when possible
# It can be triggered:
# 1. Automatically when a tag is pushed (if CI has run on that commit)
# 2. Manually via workflow_dispatch with optional cache invalidation

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      tag:
        description: 'Tag to release (e.g., v0.1.6)'
        required: true
        type: string
      force_rebuild:
        description: 'Force rebuild (ignore cache)'
        required: false
        type: boolean
        default: false
      ci_check_name:
        description: 'Name of CI check run to gate cache reuse'
        required: false
        type: string
        default: 'Build & Test'

permissions:
  contents: write
  checks: read

concurrency:
  group: release-${{ github.ref_type == 'tag' && github.ref_name || inputs.tag || github.ref_name }}
  cancel-in-progress: false

jobs:
  # Verify tag and extract metadata
  prepare:
    name: "Release: Prepare"
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.extract.outputs.version }}
      commit_sha: ${{ steps.extract.outputs.commit_sha }}
      cache_key: ${{ steps.extract.outputs.cache_key }}
      should_use_cache: ${{ steps.cache_check.outputs.should_use_cache }}
    steps:
      - name: Determine tag source
        id: tag_source
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            TAG="${{ inputs.tag }}"
          else
            TAG="${GITHUB_REF#refs/tags/}"
          fi

          if [[ ! "$TAG" =~ ^v[0-9]+\.[0-9]+\.[0-9]+(-.*)?$ ]]; then
            echo "::error::Operation failed: Invalid tag format - $TAG (Expected: v*.*.* format)"
            exit 1
          fi

          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "ðŸ“¦ Tag: $TAG"

      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Extract version and commit
        id: extract
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          TAG="${{ steps.tag_source.outputs.tag }}"
          VERSION="${TAG#v}"

          # Validate tag exists
          if ! git rev-parse "$TAG" >/dev/null 2>&1; then
            echo "::error::Operation failed: Tag not found - $TAG does not exist in repository"
            exit 1
          fi

          # Resolve tag to commit (handles lightweight and annotated)
          REF_JSON=$(gh api "repos/${{ github.repository }}/git/refs/tags/${TAG}")
          OBJ_TYPE=$(echo "$REF_JSON" | jq -r '.object.type')
          OBJ_SHA=$(echo "$REF_JSON" | jq -r '.object.sha')
          if [ "$OBJ_TYPE" = "tag" ]; then
            COMMIT_SHA=$(gh api "repos/${{ github.repository }}/git/tags/${OBJ_SHA}" --jq '.object.sha')
          else
            COMMIT_SHA="$OBJ_SHA"
          fi

          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "commit_sha=$COMMIT_SHA" >> $GITHUB_OUTPUT
          echo "ðŸ“¦ Version: $VERSION"
          echo "ðŸ”– Commit: $COMMIT_SHA"

          # Generate cache key based on commit and Cargo.lock hash
          # This ensures cache invalidation when dependencies change
          # Fallback to commit-only key if Cargo.lock doesn't exist (older tags)
          if CARGO_LOCK_HASH=$(curl --retry 3 --retry-delay 1 -fsSL "https://raw.githubusercontent.com/${{ github.repository }}/${COMMIT_SHA}/Cargo.lock" 2>/dev/null | sha256sum | cut -d' ' -f1 | head -c 8) && [ -n "$CARGO_LOCK_HASH" ]; then
            CACHE_KEY="rust-build-${COMMIT_SHA:0:8}-${CARGO_LOCK_HASH}"
          else
            echo "âš ï¸ Cargo.lock not found at commit; falling back to commit-only cache key"
            CACHE_KEY="rust-build-${COMMIT_SHA:0:8}"
          fi
          echo "cache_key=$CACHE_KEY" >> $GITHUB_OUTPUT
          echo "ðŸ“¦ Cache key: $CACHE_KEY"

      - name: Check CI status for commit
        id: cache_check
        env:
          GH_TOKEN: ${{ github.token }}
          CI_CHECK_NAME: ${{ inputs.ci_check_name || 'Build & Test' }}
        run: |
          set -euo pipefail
          COMMIT_SHA="${{ steps.extract.outputs.commit_sha }}"
          FORCE_REBUILD="${{ inputs.force_rebuild }}"

          if [[ "$FORCE_REBUILD" == "true" ]]; then
            echo "ðŸ”¨ Force rebuild requested"
            echo "should_use_cache=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Check if CI has passed for this commit
          echo "Checking CI status for commit $COMMIT_SHA..."

          # Get check runs for this commit
          CI_STATUS=$(gh api \
            "/repos/${{ github.repository }}/commits/${COMMIT_SHA}/check-runs" \
            --jq ".check_runs[] | select(.name == \"${CI_CHECK_NAME}\") | .conclusion" \
            2>/dev/null || true)

          if echo "$CI_STATUS" | grep -q '^success$'; then
            echo "âœ… CI passed for this commit - will attempt to use cache"
            echo "should_use_cache=true" >> $GITHUB_OUTPUT
          else
            echo "âš ï¸ CI hasn't passed or not found for this commit - will rebuild"
            echo "should_use_cache=false" >> $GITHUB_OUTPUT
          fi

  # Build jobs with cache support
  build-darwin-arm64:
    needs: prepare
    name: "Release: Build macOS arm64"
    runs-on: macos-14
    timeout-minutes: 45
    env:
      # Workaround for ring CPU feature detection issues on Apple Silicon
      RING_DISABLE_ASM: 1
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.prepare.outputs.commit_sha }}

      - name: "Release: Set up Rust"
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: stable

      - name: "Release: Setup cache"
        if: needs.prepare.outputs.should_use_cache == 'true'
        uses: Swatinem/rust-cache@v2
        with:
          prefix-key: "v2-rust"
          key: ${{ runner.os }}-${{ needs.prepare.outputs.cache_key }}
          cache-on-failure: true

      - name: "Release: Build (release)"
        env:
          # Ensure required CPU features are enabled at compile time for ring
          RUSTFLAGS: "-C target-feature=+neon,+aes,+sha2,+pmull"
        run: |
          if [[ "${{ needs.prepare.outputs.should_use_cache }}" == "true" ]]; then
            echo "ðŸ”„ Building with cache..."
            # Try to use cached dependencies
            cargo build --release --locked
          else
            echo "ðŸ”¨ Clean build..."
            cargo clean
            cargo build --release --locked
          fi

      - name: "Release: Prepare assets"
        run: |
          mkdir -p dist
          cp target/release/blz dist/blz-darwin-arm64
          chmod +x dist/blz-darwin-arm64

          # Create tarball for Homebrew
          cp target/release/blz blz
          tar -czf dist/blz-darwin-arm64.tar.gz blz
          rm blz
          shasum -a 256 dist/blz-darwin-arm64.tar.gz > dist/blz-darwin-arm64.tar.gz.sha256

      - name: "Release: Upload release assets"
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ needs.prepare.outputs.version }}
          generate_release_notes: true
          draft: true
          fail_on_unmatched_files: true
          files: |
            dist/blz-darwin-arm64
            dist/blz-darwin-arm64.tar.gz
            dist/blz-darwin-arm64.tar.gz.sha256
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  build-darwin-x64:
    needs: prepare
    name: "Release: Build macOS x64"
    runs-on: macos-13
    timeout-minutes: 45
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.prepare.outputs.commit_sha }}

      - name: "Release: Set up Rust"
        uses: dtolnay/rust-toolchain@stable

      - name: "Release: Setup cache"
        if: needs.prepare.outputs.should_use_cache == 'true'
        uses: Swatinem/rust-cache@v2
        with:
          prefix-key: "v2-rust"
          key: ${{ runner.os }}-${{ needs.prepare.outputs.cache_key }}
          cache-on-failure: true

      - name: "Release: Build (release)"
        run: |
          if [[ "${{ needs.prepare.outputs.should_use_cache }}" == "true" ]]; then
            echo "ðŸ”„ Building with cache..."
            cargo build --release --locked
          else
            echo "ðŸ”¨ Clean build..."
            cargo clean
            cargo build --release --locked
          fi

      - name: "Release: Prepare assets"
        run: |
          mkdir -p dist
          cp target/release/blz dist/blz-darwin-x64
          chmod +x dist/blz-darwin-x64

          # Create tarball for Homebrew
          cp target/release/blz blz
          tar -czf dist/blz-darwin-x64.tar.gz blz
          rm blz
          shasum -a 256 dist/blz-darwin-x64.tar.gz > dist/blz-darwin-x64.tar.gz.sha256

      - name: "Release: Upload release assets"
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ needs.prepare.outputs.version }}
          generate_release_notes: true
          draft: true
          fail_on_unmatched_files: true
          files: |
            dist/blz-darwin-x64
            dist/blz-darwin-x64.tar.gz
            dist/blz-darwin-x64.tar.gz.sha256
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  build-linux-x64:
    needs: prepare
    name: "Release: Build Linux x64"
    runs-on: ubuntu-latest
    timeout-minutes: 30
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.prepare.outputs.commit_sha }}

      - name: "Release: Set up Rust"
        uses: dtolnay/rust-toolchain@stable

      - name: "Release: Install lld"
        run: sudo apt-get update && sudo apt-get install -y lld

      - name: "Release: Setup cache"
        if: needs.prepare.outputs.should_use_cache == 'true'
        uses: Swatinem/rust-cache@v2
        with:
          prefix-key: "v2-rust"
          key: ${{ runner.os }}-${{ needs.prepare.outputs.cache_key }}
          cache-on-failure: true

      - name: "Release: Build (release)"
        env:
          RUSTFLAGS: "-C link-arg=-fuse-ld=lld"
        run: |
          if [[ "${{ needs.prepare.outputs.should_use_cache }}" == "true" ]]; then
            echo "ðŸ”„ Building with cache..."
            cargo build --release --locked
          else
            echo "ðŸ”¨ Clean build..."
            cargo clean
            cargo build --release --locked
          fi

      - name: "Release: Prepare assets"
        run: |
          mkdir -p dist
          cp target/release/blz dist/blz-linux-x64
          chmod +x dist/blz-linux-x64

      - name: "Release: Upload release assets"
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ needs.prepare.outputs.version }}
          generate_release_notes: true
          draft: true
          fail_on_unmatched_files: true
          files: |
            dist/blz-linux-x64
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  build-linux-arm64:
    needs: prepare
    name: "Release: Build Linux arm64"
    runs-on: ubuntu-latest
    timeout-minutes: 30
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.prepare.outputs.commit_sha }}

      - name: "Release: Set up Rust"
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: aarch64-unknown-linux-gnu

      - name: "Release: Install cross toolchain"
        run: |
          sudo apt-get update
          sudo apt-get install -y gcc-aarch64-linux-gnu

      - name: "Release: Setup cache"
        if: needs.prepare.outputs.should_use_cache == 'true'
        uses: Swatinem/rust-cache@v2
        with:
          prefix-key: "v2-rust"
          key: ${{ runner.os }}-arm64-${{ needs.prepare.outputs.cache_key }}
          cache-on-failure: true

      - name: "Release: Build (release)"
        env:
          CC_aarch64_unknown_linux_gnu: aarch64-linux-gnu-gcc
          CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_LINKER: aarch64-linux-gnu-gcc
        run: |
          if [[ "${{ needs.prepare.outputs.should_use_cache }}" == "true" ]]; then
            echo "ðŸ”„ Building with cache..."
            cargo build --release --target aarch64-unknown-linux-gnu --locked
          else
            echo "ðŸ”¨ Clean build..."
            cargo clean
            cargo build --release --target aarch64-unknown-linux-gnu --locked
          fi

      - name: "Release: Prepare assets"
        run: |
          mkdir -p dist
          cp target/aarch64-unknown-linux-gnu/release/blz dist/blz-linux-arm64
          chmod +x dist/blz-linux-arm64

      - name: "Release: Upload release assets"
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ needs.prepare.outputs.version }}
          generate_release_notes: true
          draft: true
          fail_on_unmatched_files: true
          files: |
            dist/blz-linux-arm64
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  build-windows-x64:
    needs: prepare
    name: "Release: Build Windows x64"
    runs-on: windows-latest
    timeout-minutes: 45
    env:
      # Avoid requiring nasm on Windows by disabling ring ASM paths
      RING_DISABLE_ASM: 1
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.prepare.outputs.commit_sha }}

      - name: "Release: Set up Rust"
        uses: dtolnay/rust-toolchain@stable

      - name: "Release: Setup cache"
        if: needs.prepare.outputs.should_use_cache == 'true'
        uses: Swatinem/rust-cache@v2
        with:
          prefix-key: "v2-rust"
          key: ${{ runner.os }}-${{ needs.prepare.outputs.cache_key }}
          cache-on-failure: true

      - name: Build
        run: |
          if ("${{ needs.prepare.outputs.should_use_cache }}" -eq "true") {
            Write-Host "ðŸ”„ Building with cache..."
            cargo build --release --locked
          } else {
            Write-Host "ðŸ”¨ Clean build..."
            cargo clean
            cargo build --release --locked
          }

      - name: "Release: Prepare assets"
        shell: bash
        run: |
          mkdir -p dist
          cp target/release/blz.exe dist/blz-win32-x64.exe

      - name: "Release: Upload release assets"
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ needs.prepare.outputs.version }}
          generate_release_notes: true
          draft: true
          fail_on_unmatched_files: true
          files: |
            dist/blz-win32-x64.exe
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Downstream publishing jobs
  bump-homebrew:
    name: "Publish: Homebrew Tap"
    needs: [prepare, build-darwin-arm64, build-darwin-x64]
    runs-on: ubuntu-latest
    steps:
      - name: "Publish: Download tarballs and compute SHA"
        id: tar
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          VERSION="${{ needs.prepare.outputs.version }}"
          TAG="v${VERSION}"

          # Download from draft release using gh CLI (works with draft releases)
          gh release download "$TAG" --repo "${{ github.repository }}" \
            --pattern "blz-darwin-arm64.tar.gz" --dir . --clobber
          gh release download "$TAG" --repo "${{ github.repository }}" \
            --pattern "blz-darwin-x64.tar.gz" --dir . --clobber

          SHA_ARM64=$(shasum -a 256 blz-darwin-arm64.tar.gz | cut -d' ' -f1)
          SHA_X64=$(shasum -a 256 blz-darwin-x64.tar.gz | cut -d' ' -f1)

          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "sha_arm64=$SHA_ARM64" >> $GITHUB_OUTPUT
          echo "sha_x64=$SHA_X64" >> $GITHUB_OUTPUT

      - name: "Publish: Checkout tap repo"
        uses: actions/checkout@v4
        with:
          repository: outfitter-dev/homebrew-tap
          token: ${{ secrets.HOMEBREW_TAP_TOKEN }}
          path: homebrew-tap

      - name: "Publish: Update formula"
        shell: bash
        env:
          FORMULA: |
            class Blz < Formula
              desc "Fast local search for llms.txt"
              homepage "https://blz.run"
              version "${VERSION}"

              on_macos do
                if Hardware::CPU.arm?
                  url "https://github.com/outfitter-dev/blz/releases/download/v${VERSION}/blz-darwin-arm64.tar.gz"
                  sha256 "${SHA_ARM64}"
                else
                  url "https://github.com/outfitter-dev/blz/releases/download/v${VERSION}/blz-darwin-x64.tar.gz"
                  sha256 "${SHA_X64}"
                end

                def install
                  bin.install "blz"
                end

                test do
                  assert_match version.to_s, shell_output("#{bin}/blz --version")
                end
              end
            end
        run: |
          set -euo pipefail
          VERSION="${{ steps.tar.outputs.version }}"
          SHA_ARM64="${{ steps.tar.outputs.sha_arm64 }}"
          SHA_X64="${{ steps.tar.outputs.sha_x64 }}"
          printf "%s\n" "$FORMULA" > homebrew-tap/Formula/blz.rb
          # Substitute placeholders after write to appease linters
          sed -i.bak "s/\${VERSION}/${VERSION}/g" homebrew-tap/Formula/blz.rb
          sed -i.bak "s/\${SHA_ARM64}/${SHA_ARM64}/g" homebrew-tap/Formula/blz.rb
          sed -i.bak "s/\${SHA_X64}/${SHA_X64}/g" homebrew-tap/Formula/blz.rb
          rm -f homebrew-tap/Formula/blz.rb.bak

      - name: "Publish: Create PR in tap repo"
        uses: peter-evans/create-pull-request@v6
        with:
          token: ${{ secrets.HOMEBREW_TAP_TOKEN }}
          path: homebrew-tap
          branch: bump-blz-${{ steps.tar.outputs.version }}
          commit-message: "blz ${{ steps.tar.outputs.version }}"
          title: "blz ${{ steps.tar.outputs.version }}"
          body: |
            Bump blz formula to ${{ steps.tar.outputs.version }}.
            - arm64 sha256: ${{ steps.tar.outputs.sha_arm64 }}
            - x64   sha256: ${{ steps.tar.outputs.sha_x64 }}

  cargo-publish:
    name: "Publish: crates.io"
    runs-on: ubuntu-latest
    needs: [prepare, build-linux-x64]
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.prepare.outputs.commit_sha }}

      - uses: dtolnay/rust-toolchain@stable

      - name: Install jq
        run: |
          sudo apt-get update
          sudo apt-get install -y jq

      - name: "Publish: Check publishable versions"
        id: check
        run: |
          if grep -q 'version = ".*-dev"' Cargo.toml; then
            echo "dev=true" >> $GITHUB_OUTPUT
          else
            echo "dev=false" >> $GITHUB_OUTPUT
          fi

      - name: "Publish: Verify Cargo version matches tag"
        if: steps.check.outputs.dev == 'false'
        shell: bash
        run: |
          TAG="${{ needs.prepare.outputs.version }}"
          CARGO_VER=$(grep -m1 '^version\s*=\s*"' Cargo.toml | sed 's/.*"\(.*\)".*/\1/')
          if [ "$TAG" != "$CARGO_VER" ]; then
            echo "Tag ${TAG} does not match Cargo.toml version ${CARGO_VER}" >&2
            exit 1
          fi

      - name: "Publish: Check if blz-core version exists"
        id: crate_core_exists
        run: |
          set -euo pipefail
          IFS=$'\n\t'
          VERSION="${{ needs.prepare.outputs.version }}"
          if curl --retry 3 --retry-delay 1 --fail --silent --show-error https://crates.io/api/v1/crates/blz-core/versions | jq -r '.versions[].num' | grep -qx "$VERSION"; then
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "exists=false" >> $GITHUB_OUTPUT
          fi

      - name: "Publish: Check if blz-cli version exists"
        id: crate_cli_exists
        run: |
          set -euo pipefail
          IFS=$'\n\t'
          VERSION="${{ needs.prepare.outputs.version }}"
          if curl --retry 3 --retry-delay 1 --fail --silent --show-error https://crates.io/api/v1/crates/blz-cli/versions | jq -r '.versions[].num' | grep -qx "$VERSION"; then
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "exists=false" >> $GITHUB_OUTPUT
          fi

      - name: "Publish: blz-core"
        id: publish_core
        if: steps.check.outputs.dev == 'false' && steps.crate_core_exists.outputs.exists != 'true'
        env:
          CARGO_REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}
        run: |
          cargo publish -p blz-core --locked

      - name: "Publish: wait for blz-core to propagate"
        if: steps.check.outputs.dev == 'false' && steps.crate_core_exists.outputs.exists != 'true' && steps.publish_core.outcome == 'success'
        run: |
          VERSION="${{ needs.prepare.outputs.version }}"
          echo "Waiting for blz-core $VERSION to appear on crates.io..."
          for i in {1..30}; do
            if curl --retry 3 --retry-delay 1 -fsSL https://crates.io/api/v1/crates/blz-core/versions | jq -r '.versions[].num' | grep -qx "$VERSION"; then
              echo "blz-core $VERSION is available."
              exit 0
            fi
            sleep 5
          done
          echo "Timed out waiting for blz-core $VERSION to propagate" >&2
          exit 1

      - name: "Publish: blz-cli"
        id: publish_cli
        if: steps.check.outputs.dev == 'false' && steps.crate_cli_exists.outputs.exists != 'true' && (steps.crate_core_exists.outputs.exists == 'true' || steps.publish_core.outcome == 'success')
        env:
          CARGO_REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}
        run: |
          cargo publish -p blz-cli --locked

  npm-publish:
    name: "Publish: npm"
    runs-on: ubuntu-latest
    needs: [prepare, build-linux-x64]
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.prepare.outputs.commit_sha }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          registry-url: 'https://registry.npmjs.org'
          scope: '@outfitter'

      - name: "Publish: Validate package.json version"
        run: |
          PKG=$(node -p "require('./package.json').version")
          VERSION="${{ needs.prepare.outputs.version }}"
          if [ "$VERSION" != "$PKG" ]; then
            echo "Tag version $VERSION does not match package.json version $PKG" >&2
            exit 1
          fi

      - name: "Publish: Check if npm version exists"
        id: npm_exists
        run: |
          set -euo pipefail
          IFS=$'\n\t'
          VERSION="${{ needs.prepare.outputs.version }}"
          if npm view @outfitter/blz@"$VERSION" version >/dev/null 2>&1; then
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "exists=false" >> $GITHUB_OUTPUT
          fi

      - name: "Publish: npm publish"
        if: steps.npm_exists.outputs.exists != 'true'
        run: npm publish --access public --provenance
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}

  publish-github-release:
    name: "Publish: GitHub Release"
    needs: [prepare, build-darwin-arm64, build-darwin-x64, build-linux-x64, build-linux-arm64, build-windows-x64, cargo-publish, npm-publish, bump-homebrew]
    runs-on: ubuntu-latest
    if: |
      needs.build-darwin-arm64.result == 'success' &&
      needs.build-darwin-x64.result == 'success' &&
      needs.build-linux-x64.result == 'success' &&
      needs.build-linux-arm64.result == 'success' &&
      needs.build-windows-x64.result == 'success' &&
      needs.cargo-publish.result == 'success' &&
      needs.npm-publish.result == 'success' &&
      needs.bump-homebrew.result == 'success'
    steps:
      - name: "Publish: finalize GitHub release (undraft)"
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ needs.prepare.outputs.version }}
          draft: false
          prerelease: false

  # Summary job to report status
  release-summary:
    name: "Release: Summary"
    runs-on: ubuntu-latest
    if: always()
    needs: [prepare, build-darwin-arm64, build-darwin-x64, build-linux-x64, build-linux-arm64, build-windows-x64, cargo-publish, npm-publish]
    steps:
      - name: Summary
        run: |
          {
            echo "## Release Summary for v${{ needs.prepare.outputs.version }}"
            echo ""
            echo "### Build Status:"
            echo "- macOS ARM64: ${{ needs.build-darwin-arm64.result }}"
            echo "- macOS x64: ${{ needs.build-darwin-x64.result }}"
            echo "- Linux x64: ${{ needs.build-linux-x64.result }}"
            echo "- Linux ARM64: ${{ needs.build-linux-arm64.result }}"
            echo "- Windows x64: ${{ needs.build-windows-x64.result }}"
            echo ""
            echo "### Publishing:"
            echo "- Crates.io: ${{ needs.cargo-publish.result }}"
            echo "- npm: ${{ needs.npm-publish.result }}"
            echo ""
            if [[ "${{ needs.prepare.outputs.should_use_cache }}" == "true" ]]; then
              echo "âœ… Used cached builds from CI"
            else
              echo "ðŸ”¨ Performed clean builds"
            fi
          } | tee -a "$GITHUB_STEP_SUMMARY"
  publish:
    name: "Publish: orchestrate"
    runs-on: ubuntu-latest
    needs: [prepare, build-darwin-arm64, build-darwin-x64, build-linux-x64, build-linux-arm64, build-windows-x64]
    uses: ./.github/workflows/publish.yml
    with:
      tag: v${{ needs.prepare.outputs.version }}
    secrets: inherit
